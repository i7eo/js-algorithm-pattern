### 算法

#### 算法定义

对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。简而言之，算法是**解决问题的方法与步骤**

#### 算法描述

- 自然语言（中、英文）
- 流程图
- 伪代码、类语言
- 程序代码

#### 算法与程序

算法是解决问题的一种方法或一个过程，考虑如何把输入换成输出，一个问题可以有多种算法。

程序是用某种程序设计语言对算法的具体实现。

#### 算法特性

- 有穷性
- 确定性（每一条语句没有二义性）
- 可行性（可通过**已经实现的基本操作执行有限次来实现**）
- 输入
- 输出

### 算法分析

每个问题的解都会有多个算法，那么如何评价算法的好坏则至关重要。考虑如下两方面：

- 时间效率
- 空间效率

需要注意的是时间和空间有时不能兼得，需要具体情况具体分析

### 时间效率的度量

估算法：一个简单操作（语句：赋值、比较、移动等）所需的时间*简单操作的**次数** = 算法运行时间

```javascript
for(i = 1; i <= n; i++)                       // 循环语句 n + 1 次;
  for(j = 1; j <= n; j++)                     // 循环体内 n 次，循环语句 n + 1 次; n(n+1) 
    c[i][j] = 0																// 被包在俩个循环体内 n*n 次
		for(k = 0; k < n; k++)										// n*n*(n+1)
      c[i][j] = c[i][j] + a[i][k] * b[k][j]   // n*n*n
```

为了便于比较不同的算法时间效率，我们仅比较它们的数量级：

若有某个辅助函数 f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数。记作 T(n) = O(f(n)) 称 O(f(n)) 为算法的渐进时间复杂度（O是数量级的符号），简称**时间复杂度**。O 表示描述渐进时间复杂度的函数，其中我们只需要取数量级最大的 n 即可，可忽略常数、系数。

n越大算法执行时间越长，n可以有不同的含义：

- 排序：n为记录数

- 矩阵：n为矩阵的阶数

- 多项式：n为多项式的项数

- 集合：n为元素的个数

- 树：n为树的节点个数

- 图：n为图的顶点数或边数

#### 分析算法时间复杂度的基本方法

1. 找出**语句频度最大**的那条语句作为**基本语句**
2. 计算**基本语句**的频度（层次最深）得到问题规模 n 的某个函数 f(n)
3. 取其数量级用符号 O 表示

例1:

```javascript
x = 0,
y = 0;
for(i = 0; i < n; i++)
  x ++
for(j = 0; j < n; j++)
  for(k = 0; k < n; k++)
    y ++												// 这就是基本语句的频度最大/层次最深的语句 f(n) = n*n 时间复杂度为 O(n^2)
```

例2: 

```javascript
i = 1;
while(i <= n)
  i = i * 2

// 分析：关键是要找出执行x次与n的关系，从而求出x执行次数
// 1: i = 1 * 2 = 2
// 2: i = 2 * 2 = 2^2
// 3: i = 2^2 * 2 = 2^3
// x: i = 2^x
// i <= n  =>  2^x <= n  =>  x = log2n
// 即 f(n) <= log2n 取最大值：f(n) = log2n => T(n) = O(log2n) 也可不写2这个底，写成 O(logn) 即表示对数级就可
```

#### 平均时间复杂度

有的情况下算法中基本操作重复执行的次数还会随问题规模的变化而变化，为了准确起见我们需要计算平均时间复杂度，例如：

```javascript
// 顺序查找等于e的元素
for(i = 0; i < n; i++)
  if(a[i] === e) return i + 1
return 0
```

- 最好情况 1
- 最坏情况 n
- 平均时间复杂度 O( (1+ n) / 2) => O(n)

我们常说的时间复杂度到底是什么？一般考虑的是最坏和平均时间复杂度

#### 复杂算法时间复杂度

对于复杂算法T(n)，我们可以将其分解为容易估算的部分然后利用加法与乘法法则计算出算法的时间复杂度

1. 加法法则：

   ```javascript
   T(n) = O(f1(n)) + O(f2(n)) = O(max(f1(n), f2(n))) // 取部分当中较大的计算结果即可
   ```

2. 乘法法则

   ```javascript
   T(n) = O(f1(n)) * O(f2(n)) = O(f1(n) * f2(n)) // 计算部分结果的乘积即可
   ```

#### 算法时间效率比较

常数阶 O(1) < 对数阶 O(log2n) < 线性阶 O(n) < 线性对数阶 O(nlog2n) < 平方阶 O(n^2) < 立方阶 O(n^3) < K次方阶段 O(n^k) < 指数阶 O(2n)

### 空间效率的度量

#### 空间复杂度（渐进空间复杂度）

算法所需存储空间的度量，记作：S(n) = O(f(n)) 其中 n 为问题的规模（或大小）

#### 算法占据的空间

1. 算法本身要占据的空间：
   - 输入/输出
   - 指令
   - 常数
   - 变量等
2. 算法需要的辅助空间

例子：

```javascript
// Q: 将一堆数组a中的n个数逆序放到原数组中
// A1: 
for(i = 0; i < n / 2; i++)
  t = a[i]
	a[i] = a[n - i - 1]
	a[n - i - 1] = t
// S(n) = O(1) 原地工作，只需要一个额外变量空间
// A2:
for(i = 0; i < n; i++)
  b[i] = a[n - i - 1]
for(i = 0; i < n; i++)
  a[i] = b[i]
// S(n) = O(n) 需要一个和a相同大小的数组
```





