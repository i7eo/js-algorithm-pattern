#### 单链表、循环链表、双向链表的时间效率比较

|                                     | 查找表头结点（首元结点）  |               查找表尾结点               |                    查找结点 *p 的前驱结点                    |
| :---------------------------------- | :-----------------------: | :--------------------------------------: | :----------------------------------------------------------: |
| 带头结点的**单链表L**               | L -> next 时间复杂度 O(1) | 从 L -> next 开始向后遍历时间复杂度 O(n) | 通过 p -> next 无法找到其前驱，在不提供索引的情况下根本无法实现 |
| 带头结点**仅设头指针L的循环单链表** | L -> next 时间复杂度 O(1) | 从 L -> next 开始向后遍历时间复杂度 O(n) |        可以通过 p -> next 遍历一圈找到时间复杂度 O(n)        |
| 带头结点**仅设尾指针R的循环单链表** | R -> next 时间复杂度 O(1) |            R 时间复杂度 O(1)             |        可以通过 p -> next 遍历一圈找到时间复杂度 O(n)        |
| 带头结点的**双向循环链表L**         | L -> next 时间复杂度 O(1) |        L -> prior 时间复杂度 O(1)        |           可以通过 p -> prior 找到时间复杂度 O(1)            |

#### 顺序表和链表的比较

链式存储结构：

- 优点

  1. 结点空间可以动态申请和释放

  2. 不用申请连续的存储空间来存储

  3. 数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素

- 缺点
  	1. 存储密度小（数据域占用的空间/该结点占据的所有空间），每个结点需要多余的空间存储指针，相比较于数据域而言指针的存储空间很大
   	2. 非随机存取的结构，不能通过下标取值，只能遍历

顺序表和链表个方面对比：

顺序表：

1. 存储空间：预先分配连续的空间，会导致空间闲置或者溢出
2. 存储密度：等于1，不用额外的空间存储指针
3. 存取元素：随机存取，时间复杂度 O(1)
4. 插入、删除：通过遍历平均需要移动一般的元素进行操作，时间复杂度 O(n)
5. 适用情况：表长变化不大，且事先确定变化范围；插入、删除操作较少，多位存取操作

链表：

1. 存储空间：动态分配，不存在空间闲置或者溢出
2. 存储密度：小于1，需使用额外空间存储指针
3. 存取元素：通过遍历操作，时间复杂度 O(n)
4. 插入、删除：不需移动元素，确定**插入、删除位置后**时间复杂度 O(1)，需要注意的是这里确定后才是 O(1)，未确定的情况下是 O(n)
5. 适用情况：长度变化较大，频繁进行插入、删除操作

