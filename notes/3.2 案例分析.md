### 栈的典型案例

#### 进制转换

10进制转为其他d进制（2、8、16等）方法如下：10 / d = n ... x 直到n为0后，把所有余数**倒过来**即可。

例如：十进制159转为八进制：237

思路：注意这里有**倒**即反转顺序这个步骤，所以可以考虑利用栈先进后出的特性，完成存入和输出

#### 括号匹配的检验

假设表达式有俩种括号：圆括号与方括号，其嵌套随意顺序，即：

1. ( [] () ) 或 [ ( [] [] ) ] 为正确格式
2. [ (] ] 为错误格式
3. ( [ () ) 为错误格式

思路：从左到右一个个来，依次压入栈，如果匹配到就弹出，匹配不到就失败。主要利用了栈的先进后出、后进先出的存储规则，得先保存前一步的数据（状态）然后根据后面进入的数据进行比较。

#### 表达式求值

表达式求值是程序设计语言编译中的一个最基本的问题，它的实现也需要运用栈。这里介绍的算法是由运算符优先级确定运算顺序的对表达式求值算法（算符优先算法）

例如：`3 * ( 7 - 2 );` 其中：

- operand（操作数）：常量、变量
- operator（运算符）：算术运算符、关系运算符、逻辑运算符。
- delimiter（界限符）：左右括号和表达式结束符

思路：

设置俩个栈分别为：

- optr 存储运算符
- opnd 存储操作数和运算结果

求值过称为：

- 当扫描到的是操作数，则将其压入栈 opnd
- 当扫描到的是运算符时
  - 若这个运算符比optr栈顶的运算符优先级高，则入栈optr，继续向后处理
  - 若这个运算符比optr栈顶运算符优先级低，则从opnd栈中弹出俩个运算数，从栈optr中弹出栈顶运算符进行运算，得到结果后入栈opnd
- 继续处理当前字符，直到遇到结束符为止

### 队列的典型案例

#### 舞伴问题

假设在舞会上，男士和女士各自拍成一队。舞会开始时，依次从男队和女队头部各自出一人配成舞伴。如果俩队初始人数不同。则较长的那一队中未配对者等待下一轮舞曲。

思路：

很明显的先进先出问题，使用队列。

- 依次构造俩个队列，一个存储男士，一个存储女士
- 依次将队头元素出队配成舞伴
- 某队为空时，则另外一队等待的是（该舞曲结束后从个队列队尾回到自己的队列）下一舞曲开始时候队头的人

